package main

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"github.com/magefile/mage/sh"
	"github.com/mlctrez/factop/softmod"
	"github.com/nats-io/nats.go"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"
)

const Host = "factorio"

var Default = Softmod

// prevent function names from being greyed out in IDE
var _ = []interface{}{Default, Protoc, Service, Softmod, Command, Rcon, PRcon, LRcon}

func Protoc() (err error) {
	if err = sh.Run("protoc", "--go_out=.", "--nrpc_out=.", "api/api.proto"); err != nil {
		return err
	}
	// replace first line in api/api.nrpc.go to remove warning about package comment
	return sh.Run("sed", "-i", `1s/.*/\/\/ Code generated by nRPC protoc plugin. DO NOT EDIT./`, "api/api.nrpc.go")
}

func Service() (err error) {
	var tempDir string
	if tempDir, err = os.MkdirTemp("", "factop"); err != nil {
		return err
	} else {
		defer func() { _ = os.RemoveAll(tempDir) }()
	}

	binPath := filepath.Join(tempDir, "factop")
	if err = sh.Run("go", "build", "-o", binPath, "factop.go"); err != nil {
		return err
	}

	fmt.Println("deploying", filepath.Base(binPath), "to", Host)
	var binFile []byte
	if binFile, err = os.ReadFile(binPath); err != nil {
		return err
	}

	var req *http.Request
	u := fmt.Sprintf("https://%s:2000/deploy/%s", Host, "factop")
	if req, err = http.NewRequest("POST", u, bytes.NewBuffer(binFile)); err != nil {
		return err
	}

	var res *http.Response
	if res, err = http.DefaultClient.Do(req); err != nil {
		return err
	}

	if res.StatusCode != 200 {
		return fmt.Errorf("incorrect status code %d", res.StatusCode)
	}
	fmt.Println("factop deploy success")
	return nil
}

func Softmod() (err error) {
	var conn *nats.Conn
	if conn, err = nats.Connect("nats://factorio"); err != nil {
		return err
	}
	defer conn.Close()

	var buffer *bytes.Buffer
	if buffer, err = softmod.CreateZip("save"); err != nil {
		return err
	}

	return sendMessage(conn, "factorio.softmod", buffer.Bytes())
}

func Command(name string) (err error) {
	var conn *nats.Conn
	if conn, err = nats.Connect("nats://factorio"); err != nil {
		return err
	}
	defer conn.Close()
	return sendMessage(conn, "factop.command", []byte(name))
}

func PRcon(delay int, path string) (err error) {
	ticker := time.NewTicker(time.Duration(delay) * time.Second)
	defer ticker.Stop()
	if err = Rcon(path); err != nil {
		return err
	}

	for range ticker.C {
		if err = Rcon(path); err != nil {
			return err
		}
	}
	return nil
}

func Rcon(path string) (err error) {
	var conn *nats.Conn
	if conn, err = nats.Connect("nats://factorio"); err != nil {
		return err
	}
	defer conn.Close()

	var file []byte
	if file, err = os.ReadFile(path); err != nil {
		return err
	}
	scanner := bufio.NewScanner(bytes.NewReader(file))
	var lines []string
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line != "" && !strings.HasPrefix(line, "--") {
			lines = append(lines, line)
		}
	}

	return sendMessage(conn, "factop.rcon", []byte("/sc "+strings.Join(lines, "\n")))
}

func LRcon(path string) (err error) {
	var conn *nats.Conn
	if conn, err = nats.Connect("nats://localhost"); err != nil {
		return err
	}
	defer conn.Close()

	var file []byte
	if file, err = os.ReadFile(path); err != nil {
		return err
	}

	msg, err := conn.Request("rcon", file, 5*time.Second)
	if err != nil {
		return err
	}
	response := string(msg.Data)
	if response != "" {
		fmt.Println(response)
	}
	return nil
}

func sendMessage(conn *nats.Conn, subject string, data []byte) (err error) {
	response, err := conn.Request(subject, data, time.Second*10)
	if err != nil {
		return err
	}
	responseError := response.Header.Get("error")
	if responseError != "" {
		return errors.New(responseError)
	}
	if len(response.Data) > 0 {
		fmt.Println(string(response.Data))
	}
	return nil
}
